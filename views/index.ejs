<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
  </head>
  <body>
    <!--<h1><%= title %></h1>-->
    <!--<p>Welcome to <%= title %></p>-->
  </body>
  <script src="/javascripts/jquery-2.2.4.min.js"></script>
  <script src="/javascripts/three.min.js"></script>
  <script src="/javascripts/OrbitControls.js"></script>
  <script src="/javascripts/TransformControls.js"></script>

  <script>
    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight);

    document.body.appendChild( renderer.domElement );
    camera.position.z = 350;


    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.damping = 0.2;

//    drawCubic();
//    trackMouseMove();
    dot = null;
    genAxis(scene);
    locCubic(scene,camera);

    var render = function () {
      requestAnimationFrame( render );
      renderer.render(scene, camera);
    };

    render();

    function locCubic(scene,camera){
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();


      $(document).mousedown(function(event){
        if(!event.altKey)return;
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        /*
         distance – distance between the origin of the ray and the intersection
         point – point of intersection, in world coordinates
         face – intersected face
         faceIndex – index of the intersected face
         indices – indices of vertices comprising the intersected face
         object – the intersected object
         */
        var intersects = raycaster.intersectObjects( scene.children );
        if(intersects.length >0){

          var transformControl = new THREE.TransformControls( camera, renderer.domElement );
          if(dot == undefined){
            var dotGeometry = new THREE.Geometry();
            dotGeometry.vertices.push(new THREE.Vector3( 0, 0, 0));
            var dotMaterial = new THREE.PointCloudMaterial( { size: 1, sizeAttenuation: false } );
            dot = new THREE.PointCloud( dotGeometry, dotMaterial );
            scene.add( dot );
          }

          dot.position.copy(intersects[0].point);

          transformControl.attach(dot)
          scene.add( transformControl );

          // Hiding transform situation is a little in a mess :()
//          transformControl.addEventListener( 'change', function( e ) {
//
//            cancelHideTransform();
//
//          } );
//
//          transformControl.addEventListener( 'mouseDown', function( e ) {
//
//            cancelHideTransform();
//
//          } );
//
//          transformControl.addEventListener( 'mouseUp', function( e ) {
//
//            delayHideTransform();
//
//          } );
//
//          transformControl.addEventListener( 'objectChange', function( e ) {
//
////            updateSplineOutline();
//
//          } );

//
//          controls.addEventListener( 'start', function() {
//
//            cancelHideTransform();
//
//          } );
//
//          controls.addEventListener( 'end', function() {
//
//            delayHideTransform();
//
//          } );

          var hiding;

          function delayHideTransform() {

            cancelHideTransform();
            hideTransform();

          }

          function hideTransform() {

//            hiding = setTimeout( function() {
//
//              transformControl.detach( transformControl.object );
//
//            }, 2500 )

          }

          function cancelHideTransform() {

            if ( hiding ) clearTimeout( hiding );

          }

        }

//        intersects[ 0 ].object.material.color.set( 0xffffff );
//
//        for ( var i = 0; i < intersects.length; i++ ) {
//
//
//        }

        renderer.render( scene, camera );
      });
    }


//    function genFont(str){
//      // create a canvas element
//      var canvas1 = document.createElement('canvas');
//      var context1 = canvas1.getContext('2d');
//      context1.font = "20px Arial";
//      context1.fillStyle = "rgba(255,0,0,1)";
//      context1.fillText(str, 0,20);
//
//      // canvas contents will be used for a texture
//      var texture1 = new THREE.Texture(canvas1)
//      texture1.needsUpdate = true;
//
//      var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
//      material1.transparent = true;
//
//      var mesh1 = new THREE.Mesh(
//              new THREE.PlaneGeometry(canvas1.width, canvas1.height),
//              material1
//      );
//      return mesh1;
//    }

    function genAxis(scene){

      var x_geometry = new THREE.PlaneBufferGeometry( 512, 512);

      texture = THREE.ImageUtils.loadTexture( "output/ser002img00001.dcm.jpeg" );

// assuming you want the texture to repeat in both directions:
//      texture.wrapS = THREE.RepeatWrapping;
//      texture.wrapT = THREE.RepeatWrapping;

//// how many times to repeat in each direction; the default is (1,1),
////   which is probably why your example wasn't working
//      texture.repeat.set( 4, 4 );

      var plane_material  = new THREE.MeshBasicMaterial({ map : texture });

      var x_plane = new THREE.Mesh( x_geometry, plane_material );
      x_plane.material.side = THREE.DoubleSide;
      scene.add( x_plane );




//      var font = genFont('x');
//      font.position.x = 100;
//      font.position.y = -20;
//      scene.add(font);


//      var y_geometry = new THREE.PlaneBufferGeometry( 100, 100);
//      var plane_material = new THREE.MeshBasicMaterial( {color: 0xff0000,wireframe: true} );
//      var y_plane = new THREE.Mesh( y_geometry, plane_material );
//      y_plane.rotation.x = Math.PI/2;
//      var y_font = genFont('y');
//      y_font.position.x = 100;
//      y_font.position.z = -20;
//      y_font.rotation.x = Math.PI/2;
//
//      scene.add(y_font);
//      scene.add( y_plane );


//      var z_geometry = new THREE.PlaneBufferGeometry( 100, 100);
//      var plane_material = new THREE.MeshBasicMaterial( {color: 0x0000ff,wireframe: true} );
//      var z_plane = new THREE.Mesh( z_geometry, plane_material );
//      z_plane.rotation.y = Math.PI/2;
//      var z_font = genFont('z');
//      z_font.position.z = -100;
//      z_font.position.y = -20;
//      z_font.rotation.y = Math.PI/2;
//      scene.add(z_font);
//      scene.add( z_plane );


//      var dotGeometry = new THREE.Geometry();
//      dotGeometry.vertices.push(new THREE.Vector3( 0, 0, 0));
//      var dotMaterial = new THREE.PointCloudMaterial( { size: 10, sizeAttenuation: false } );
//      dot = new THREE.PointCloud( dotGeometry, dotMaterial );
//      scene.add( dot );
    }

//    function trackMouseMove(){
//      $(document).mousemove(function(event){
//        var vector = new THREE.Vector3();
//
//        vector.set(
//                ( event.clientX / window.innerWidth ) * 2 - 1,
//                - ( event.clientY / window.innerHeight ) * 2 + 1,
//                0.5 );
//
//        vector.unproject( camera );
////        projector.unprojectVector(vector, camera);
//
//        var dir = vector.sub( camera.position ).normalize();
//
//        var distance = - camera.position.z / dir.z;
//
//        var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
//
//        dot.position.copy(pos);
//
//        console.debug(pos);
//
//      })
//    }

//    function getPointPosition(event){
//      var vector = new THREE.Vector3();
//
//      vector.set(
//              ( event.clientX / window.innerWidth ) * 2 - 1,
//              - ( event.clientY / window.innerHeight ) * 2 + 1,
//              0.5 );
//
//      vector.unproject( camera );
////        projector.unprojectVector(vector, camera);
//
//      var dir = vector.sub( camera.position ).normalize();
//
//      var distance = - camera.position.z / dir.z;
//
//      var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
//
//      return vector;
//    }



//    function drawCubic(){
//      $(document).mousemove(function(event){
//
//        var curPos = getPointPosition(event);
//        console.debug(curPos);
//
//        if(drawing){
//          var curPos = getPointPosition(event);
//          var movingVector = curPos.sub(startPos);
//          currentCube.scale.copy(movingVector);
//          console.debug('moving vector:',movingVector);
//          console.debug('currentCube');
//
//        }
//      });
//
//      var drawing = false;
//      var currentCube = null;
//      var startPos = null;
//      $(document).mousedown(function(event){
//        if(event.altKey){
//
//          drawing = true;
//          orbit.enableZoom = false;
//          orbit.enabled = false;
//
//          var geometry = new THREE.BoxBufferGeometry( 5, 5, 5 );
//          var material = new THREE.MeshBasicMaterial( { color: 0x00ff00,
//            wireframe: true } );
//          var cube = new THREE.Mesh( geometry, material );
//          currentCube = cube;
//          var curPos = getPointPosition(event);
//          startPos = curPos;
//          cube.position.copy(curPos);
//          scene.add( cube );
//
//        }
//
//      });
//
//
//      $(document).mouseup(function(event){
//        drawing = false;
//        orbit.enableZoom = true;
//        orbit.enabled = true;
//      });
//
//
//
//
//    }



//    function updateGroupGeometry( mesh, geometry ) {
//
//      mesh.children[ 0 ].geometry.dispose();
//      mesh.children[ 1 ].geometry.dispose();
//
//      mesh.children[ 0 ].geometry = new THREE.WireframeGeometry( geometry );
//      mesh.children[ 1 ].geometry = geometry;
//
//      // these do not update nicely together if shared
//
//    }

  </script>
</html>
