<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
  </head>
  <body>
    <!--<h1><%= title %></h1>-->
    <!--<p>Welcome to <%= title %></p>-->
  </body>
  <script src="/javascripts/jquery-2.2.4.min.js"></script>
  <script src="/javascripts/three.min.js"></script>
  <script src="/javascripts/OrbitControls.js"></script>
  <script src="/javascripts/TransformControls.js"></script>

  <script>
    var scene = new THREE.Scene();
    var x_plane = null;
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight);

    document.body.appendChild( renderer.domElement );
    camera.position.z = 450;


    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.damping = 0.2;

//    drawCubic();
//    trackMouseMove();
    dot = null;
    genAxis(scene);
    genOuterBox(scene);
    locCubic(scene,camera);

    var render = function () {
      requestAnimationFrame( render );
      renderer.render(scene, camera);
    };

    render();

    function locCubic(scene,camera){
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();


      $(document).mousedown(function(event){
        if(!event.altKey)return;
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        /*
         distance – distance between the origin of the ray and the intersection
         point – point of intersection, in world coordinates
         face – intersected face
         faceIndex – index of the intersected face
         indices – indices of vertices comprising the intersected face
         object – the intersected object
         */
        var intersects = raycaster.intersectObjects( scene.children );
        if(intersects.length >0){

          var transformControl = new THREE.TransformControls( camera, renderer.domElement );
          if(dot == undefined){
            var dotGeometry = new THREE.Geometry();
            dotGeometry.vertices.push(new THREE.Vector3( 0, 0, 0));
            var dotMaterial = new THREE.PointCloudMaterial( { size: 1, sizeAttenuation: false } );
            dot = new THREE.PointCloud( dotGeometry, dotMaterial );
            scene.add( dot );
          }

          dot.position.copy(intersects[0].point);

          transformControl.attach(dot)
          scene.add( transformControl );

        }

        renderer.render( scene, camera );
      });
    }



    function genAxis(scene){

      var x_geometry = new THREE.PlaneBufferGeometry( 512, 512);

      var texture = THREE.ImageUtils.loadTexture( "output/ser002img00001.dcm.jpeg" );

      var plane_material  = new THREE.MeshBasicMaterial({ map : texture });

      x_plane = new THREE.Mesh( x_geometry, plane_material );
      x_plane.material.side = THREE.DoubleSide;

//      var outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.BackSide } );
//      var outlineMesh1 = new THREE.Mesh( x_geometry, outlineMaterial1 );
//      outlineMesh1.position = x_geometry.position;
//      outlineMesh1.scale.multiplyScalar(1.05);


      edges = new THREE.EdgesHelper( x_plane, 0x00ff00 );
//      edges.scale.multiplyScalar(1.0005);
//      edges.matrixAutoUpdate = true;

      scene.add( x_plane );

      scene.add( edges );

    }

    function genOuterBox(scene){
      var geometry = new THREE.BoxGeometry( 512, 512, 28*10 );
      var material = new THREE.MeshBasicMaterial( {color: 0x00ff00,wireframe:true} );
      var cube = new THREE.Mesh( geometry, material );

      var egh = new THREE.EdgesHelper( cube, 0x00ffff );
      egh.material.linewidth = 1;
      egh.position.setZ(28*10/2);
      egh.matrixAutoUpdate = true;

      scene.add( egh );
    }

    function moveSlide(id){
      sId = ("00"+id).slice(-2);
      x_plane.material.map = THREE.ImageUtils.loadTexture( "output/ser002img000"+sId+".dcm.jpeg" );
      x_plane.material.needsUpdate = true;
      x_plane.position.setZ(id*10);

    }


  </script>
</html>
